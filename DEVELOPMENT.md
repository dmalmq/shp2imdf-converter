# SHP→IMDF Converter — Development Guide

## Project Overview

A decoupled web application that converts Shapefiles (.shp)
into Apple Indoor Mapping Data Format (IMDF) archives. A
Python (FastAPI) backend handles all geospatial processing
while a React (MapLibre GL JS) frontend provides a guided
wizard for configuration followed by an interactive map +
table view for visual review, validation, and export.

Designed for indoor mapping professionals who work with
per-floor shapefiles. Runs as a single server on a shared
Windows PC — colleagues access it via browser URL with no
client-side installation.

## IMDF Feature Summary

The converter produces the following IMDF feature types.
See SPEC.md Section 2 for complete property structures.

| Feature   | Geometry   | Key Properties                      |
| --------- | ---------- | ----------------------------------- |
| Address   | null       | address, locality, country          |
| Venue     | Polygon    | name, category, address_id          |
| Building  | null       | name, category, address_id          |
| Footprint | Polygon    | category, building_ids              |
| Level     | Polygon    | ordinal, name, short_name, outdoor, |
|           |            | building_ids                        |
| Unit      | Polygon    | category, level_id, name            |
| Opening   | LineString | category, level_id, door            |
| Fixture   | Polygon    | category, level_id                  |
| Detail    | LineString | level_id (only property)            |

Key structural rules:

- Building and Address have null geometry (unlocated)
- Detail is LineString, not Point, with no name/category
- Names use LABELS format: `{"en": "Name"}`
- Level references buildings via building_ids (array)
- Footprint references buildings via building_ids (array)
- Venue display_point is required; building display_point
  must be within a referencing footprint

## Stack

**Backend (API & Geospatial Engine):**

- Python 3.11+
- FastAPI & Uvicorn for the REST API and server
- Pydantic for API data validation and serialization
- GeoPandas for shapefile reading and geometry operations
- Shapely for geometry manipulation (union, hull, buffer)
- Fiona for low-level shapefile inspection
- pyproj for CRS detection and reprojection
- jsonschema for IMDF schema validation

**Frontend (UI & Mapping):**

- React 18+ with TypeScript
- Vite for build tooling and dev server
- MapLibre GL JS v4+ with `react-map-gl/maplibre` for
  interactive WebGL map rendering
- TanStack Table for headless data tables with inline
  editing
- TanStack Query (React Query) for API data fetching,
  caching, and cache invalidation after mutations
- Zustand for global state management (selection, filters,
  wizard state, edit history)
- Tailwind CSS for utility-first styling
- Shadcn UI for polished, accessible component primitives
- react-dropzone for drag-and-drop file and folder upload

## Commands

**Backend:**

- `uvicorn backend.main:app --reload`: Start backend
  with auto-reload (dev)
- `uvicorn backend.main:app --host 0.0.0.0 --port 8000`:
  Start for network access (production)
- `python -m pytest backend/tests/`: Run backend tests
- `python -m pytest backend/tests/ -v`: Verbose
- `python -m pytest backend/tests/ -m phase1 -v`: Single
  phase

**Frontend:**

- `cd frontend && npm ci`: Install deps
- `cd frontend && npm run dev`: Dev server (port 5173,
  proxies API to backend)
- `cd frontend && npm run build`: Production build to
  `frontend/dist/`
- `cd frontend && npm run test`: Frontend tests (Vitest)

**Production (single server):**

- `cd frontend && npm run build`
- `uvicorn backend.main:app --host 0.0.0.0 --port 8000`

## Testing Strategy

### Test Fixture Generation

Sample shapefiles live in `backend/tests/fixtures/` and
are generated by a script:

```bash
python backend/tests/generate_fixtures.py
```

Creates a `tokyo_station/` set (3 levels, units with
company codes, openings, fixtures, details as LineStrings)
and an `edge_cases/` set (missing .prj, empty file,
invalid geometry, overlapping units, MultiPolygons,
duplicates, slivers, detached openings, flipped
coordinates).

### Shared Fixtures (`backend/tests/conftest.py`)

Pytest fixtures:

- `sample_dir` — path to `fixtures/tokyo_station/`
- `edge_case_dir` — path to `fixtures/edge_cases/`
- `loaded_gdfs` — dict of `{stem: GeoDataFrame}` in WGS84
- `sample_config` — parsed `filename_keywords.json`
- `sample_categories` — parsed `unit_categories.json`
- `sample_company_mappings` — parsed `company_mappings.json`
- `test_client` — FastAPI `TestClient` with pre-loaded
  session

### Running Tests

```bash
# Full backend suite
python -m pytest backend/tests/ -v

# By file
python -m pytest backend/tests/test_importer.py -v
python -m pytest backend/tests/test_detector.py -v
python -m pytest backend/tests/test_mapper.py -v
python -m pytest backend/tests/test_generator.py -v
python -m pytest backend/tests/test_converter.py -v
python -m pytest backend/tests/test_validator.py -v
python -m pytest backend/tests/test_autofix.py -v
python -m pytest backend/tests/test_api.py -v
python -m pytest backend/tests/test_edge_cases.py -v

# By phase
python -m pytest -m phase1 -v

# Frontend
cd frontend && npm run test
```

### Phase Markers

```ini
[tool.pytest.ini_options]
markers =
    phase0: Test fixture generation
    phase1: Foundation (importer, API, upload screen)
    phase2: Wizard detection (detector, classification, levels)
    phase3: Wizard mapping (mapper, config, generation setup)
    phase4: Review (generator, map, table, selection)
    phase5: Validation and export (converter, validator, autofix)
    phase6: Polish and edge cases
```

### Manual Verification

Each phase has a "testable app state" in SPEC.md Section 12.
After completing a phase:

1. `python -m pytest -m phaseN -v` — all pass
2. Start backend + frontend — loads without errors
3. Walk through the testable app state checklist

## Deployment

### Architecture

Single server process running on a shared Windows PC that
colleagues can reach over the local network. FastAPI serves
both the REST API (`/api/...`) and the built React frontend
(static files from `frontend/dist/`). Colleagues open
`http://<pc-hostname>:8000` in their browser. No
client-side installation required.

Default profile stores sessions in memory, which is fine for
local development. For shared multi-user usage, prefer a
persistent session backend (filesystem or Redis) so active
sessions survive service restarts.

### Reproducible Setup Files

Keep runtime setup in version-controlled files:

- `environment.yml`: preferred pinned Python/geospatial env
  for Windows hosts
- `backend/requirements.txt`: pip fallback and CI install
  input
- `frontend/package-lock.json`: committed lockfile, installed
  with `npm ci`
- `.env.example`: documented runtime variables for all
  environments

### Production Setup (Shared Windows PC)

```bash
# 1. Clone
git clone <repo-url> shp2imdf
cd shp2imdf

# 2. Python environment (preferred)
conda env create -f environment.yml
conda activate shp2imdf

# If environment.yml is not available yet:
# conda create -n shp2imdf python=3.11 -y
# conda activate shp2imdf

pip install -r backend/requirements.txt

# 3. Build frontend
cd frontend
npm ci
npm run build
cd ..

# 4. Start
uvicorn backend.main:app --host 0.0.0.0 --port 8000
```

Colleagues open `http://<pc-hostname>:8000` or
`http://<pc-ip-address>:8000` in their browser.

### Running as a Windows Service

Prefer NSSM and `conda run` instead of `conda activate` in a
service context.

```bash
mkdir C:\path\to\shp2imdf\logs
nssm install shp2imdf "C:\Users\<user>\miniconda3\condabin\conda.bat"
nssm set shp2imdf AppDirectory "C:\path\to\shp2imdf"
nssm set shp2imdf AppParameters "run -n shp2imdf uvicorn backend.main:app --host 0.0.0.0 --port 8000"
nssm set shp2imdf AppStdout "C:\path\to\shp2imdf\logs\stdout.log"
nssm set shp2imdf AppStderr "C:\path\to\shp2imdf\logs\stderr.log"
nssm set shp2imdf AppRotateFiles 1
nssm set shp2imdf Start SERVICE_AUTO_START
nssm start shp2imdf
```

If you prefer a batch file wrapper, call `conda run -n
shp2imdf ...` in the batch file and keep logs redirected.

### Windows Firewall

The shared PC may need a firewall rule for incoming traffic on
port 8000. Restrict access to the local subnet where possible.
Run in elevated PowerShell:

```powershell
New-NetFirewallRule -DisplayName "SHP2IMDF (LocalSubnet)" -Direction Inbound -Protocol TCP -LocalPort 8000 -Action Allow -RemoteAddress LocalSubnet -Profile Private
```

### Updating

After pulling code updates:

```bash
cd C:\path\to\shp2imdf
call conda activate shp2imdf
pip install -r backend/requirements.txt
cd frontend
npm ci
npm run build
cd ..
# Restart the server (or restart the Windows service)
```

### Environment Variables

Core variables (current behavior):

| Variable            | Default | Description                           |
| ------------------- | ------- | ------------------------------------- |
| `SESSION_TTL_HOURS` | 24      | Hours before inactive sessions expire |
| `MAX_SESSIONS`      | 5       | Maximum concurrent sessions in memory |
| `PORT`              | 8000    | Server port                           |

Recommended variables before broader shared deployment:

| Variable               | Default                 | Description                                    |
| ---------------------- | ----------------------- | ---------------------------------------------- |
| `HOST`                 | `0.0.0.0`               | Bind host for Uvicorn                          |
| `CORS_ALLOWED_ORIGINS` | `http://localhost:5173` | Comma-separated allowed origins                |
| `LOG_LEVEL`            | `INFO`                  | Application log level                          |
| `MAX_UPLOAD_MB`        | `1024`                  | Max upload payload size                        |
| `SESSION_BACKEND`      | `memory`                | `memory`, `filesystem`, or `redis`             |
| `SESSION_DATA_DIR`     | `./data/sessions`       | Session path when `SESSION_BACKEND=filesystem` |
| `TEMP_DATA_DIR`        | `./data/tmp`            | Temporary file/work directory                  |

### Development Setup

Run backend and frontend separately with hot-reload:

```bash
# Terminal 1: Backend
uvicorn backend.main:app --reload

# Terminal 2: Frontend
cd frontend
npm run dev
```

Vite proxies `/api` to the backend. Configure in
`frontend/vite.config.ts`:

```typescript
export default defineConfig({
  server: {
    proxy: {
      "/api": "http://localhost:8000",
    },
  },
});
```

### Setup Smoke Test

After initial setup, run a quick smoke test:

```bash
# Backend importer/API sanity
python -m pytest backend/tests/test_importer.py -v
python -m pytest backend/tests/test_api.py -v

# Frontend sanity
cd frontend
npm run test
npm run build
```

Then start backend and verify docs endpoint responds:

```powershell
Invoke-WebRequest http://localhost:8000/docs | Select-Object -ExpandProperty StatusCode
```

### Documentation Ownership

To reduce drift between docs:

- `DEVELOPMENT.md` is the setup/deployment source of truth
- `README.md` stays as a short quickstart entry point
- `SPEC.md` captures product and API behavior requirements

## Project Structure

```
shp2imdf/
├── backend/
│   ├── main.py                     # FastAPI app, static file mount, CORS,
│   │                               # session cleanup background task
│   ├── requirements.txt            # Python dependencies
│   ├── config/
│   │   ├── filename_keywords.json  # Filename → feature type mapping
│   │   ├── unit_categories.json    # IMDF standard categories
│   │   └── company_mappings.json   # Sample company code mappings
│   ├── src/
│   │   ├── __init__.py
│   │   ├── importer.py             # Shapefile reading, CRS, reprojection,
│   │   │                           # import-time geometry cleanup
│   │   ├── detector.py             # Auto-detection from filenames
│   │   ├── mapper.py               # Attribute → IMDF property mapping,
│   │   │                           # LABELS wrapping
│   │   ├── generator.py            # Auto-generate address, footprint,
│   │   │                           # building (null geom), venue, levels,
│   │   │                           # display points, property assembly
│   │   ├── converter.py            # Final IMDF GeoJSON assembly per
│   │   │                           # Section 2 property structures
│   │   ├── validator.py            # Full IMDF validation suite
│   │   ├── models.py               # IMDF feature dataclasses matching
│   │   │                           # Section 2 (domain objects)
│   │   ├── schemas.py              # Pydantic models (API contract)
│   │   └── session.py              # In-memory session management + TTL
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── import_router.py        # POST /api/import
│   │   ├── files_router.py         # Files endpoints
│   │   ├── wizard_router.py        # Wizard step config endpoints
│   │   ├── config_router.py        # Keywords + company mappings upload
│   │   ├── features_router.py      # Features CRUD endpoints
│   │   ├── generate_router.py      # POST /api/session/{id}/generate
│   │   └── export_router.py        # Validate + autofix + export endpoints
│   └── tests/
│       ├── __init__.py
│       ├── conftest.py             # Shared fixtures + TestClient
│       ├── generate_fixtures.py    # Sample shapefile generator
│       ├── test_importer.py        # Phase 1
│       ├── test_api.py             # Phase 1+: endpoint tests
│       ├── test_detector.py        # Phase 2
│       ├── test_mapper.py          # Phase 3
│       ├── test_generator.py       # Phase 4
│       ├── test_converter.py       # Phase 5
│       ├── test_validator.py       # Phase 5
│       ├── test_autofix.py         # Phase 5
│       ├── test_edge_cases.py      # Phase 6
│       └── fixtures/
│           ├── tokyo_station/
│           └── edge_cases/
├── frontend/
│   ├── package.json
│   ├── tsconfig.json
│   ├── vite.config.ts              # Dev proxy to backend
│   ├── tailwind.config.ts
│   ├── index.html
│   ├── public/
│   └── src/
│       ├── main.tsx                # React entry point
│       ├── App.tsx                 # Router: Upload → Wizard → Review
│       ├── api/
│       │   └── client.ts           # Typed fetch wrappers
│       ├── store/
│       │   └── useAppStore.ts      # Zustand (session, selection, filters,
│       │                           # wizard state, edit history stack)
│       ├── pages/
│       │   ├── UploadPage.tsx      # Drop zone + file progress + cleanup
│       │   ├── WizardPage.tsx      # Wizard shell + step routing
│       │   └── ReviewPage.tsx      # Map + table + properties + validation
│       ├── components/
│       │   ├── ui/                 # Shadcn UI primitives (auto-generated)
│       │   │   ├── button.tsx
│       │   │   ├── input.tsx
│       │   │   ├── select.tsx
│       │   │   ├── accordion.tsx
│       │   │   ├── badge.tsx
│       │   │   ├── toast.tsx
│       │   │   ├── dialog.tsx
│       │   │   ├── dropdown-menu.tsx
│       │   │   ├── tabs.tsx
│       │   │   └── ...
│       │   ├── wizard/
│       │   │   ├── StepSidebar.tsx     # Step list with progress + skip link
│       │   │   ├── ProjectInfoStep.tsx # Venue name, category, address,
│       │   │   │                       # structured address form
│       │   │   ├── FileClassStep.tsx   # File → type table + preview map
│       │   │   ├── LevelMapStep.tsx    # Level ordinals, short_name, outdoor,
│       │   │   │                       # category + stacking diagram
│       │   │   ├── BuildingStep.tsx    # Building assignment, category,
│       │   │   │                       # per-building address toggle
│       │   │   ├── UnitMapStep.tsx     # Category mapping + preview table
│       │   │   ├── OpeningMapStep.tsx  # Category, accessibility,
│       │   │   │                       # access_control, door mapping
│       │   │   ├── FixtureMapStep.tsx  # Name, alt_name, category mapping
│       │   │   ├── DetailMapStep.tsx   # Confirmation only (no properties)
│       │   │   ├── FootprintStep.tsx   # Footprint method selector
│       │   │   └── SummaryStep.tsx     # Read-only summary + confirm
│       │   ├── review/
│       │   │   ├── MapPanel.tsx        # MapLibre canvas + layers (located
│       │   │   │                       # types only, Detail as thin line)
│       │   │   ├── LayerTree.tsx       # Visibility checkboxes
│       │   │   ├── TablePanel.tsx      # TanStack Table wrapper (all types
│       │   │   │                       # including unlocated)
│       │   │   ├── FilterBar.tsx       # Type, level, status, search
│       │   │   ├── PropertiesPanel.tsx # Feature editing + issue banner,
│       │   │   │                       # adapted fields per feature type
│       │   │   ├── ValidationBar.tsx   # Error/warning summary bar
│       │   │   └── ExportDialog.tsx    # Export confirmation screen
│       │   └── shared/
│       │       ├── ErrorBoundary.tsx   # Catches MapLibre + render errors
│       │       ├── Toolbar.tsx         # Top bar (back, project, actions)
│       │       ├── ConfidenceDot.tsx   # Green/yellow/red indicator
│       │       ├── StatusBadge.tsx     # mapped/warning/error badge
│       │       ├── PreviewMap.tsx      # Small map for wizard steps
│       │       ├── StackingDiagram.tsx # Level stacking visualization
│       │       └── SaveIndicator.tsx   # "Saved ✓" auto-save feedback
│       ├── hooks/
│       │   ├── useMapSelection.ts  # Map click → store sync
│       │   ├── useFeatureData.ts   # TanStack Query: fetch + cache GeoJSON
│       │   ├── useWizardState.ts   # Wizard step management
│       │   └── useUndoStack.ts     # Ctrl+Z edit history
│       ├── types/
│       │   └── index.ts            # TypeScript interfaces matching IMDF
│       │                           # Section 2 property structures
│       └── lib/
│           ├── colors.ts           # IMDF category → color mapping
│           └── mapStyles.ts        # MapLibre layer style definitions
│                                   # (Detail as thin line, etc.)
├── README.md
├── DEVELOPMENT.md
├── SPEC.md
└── .gitignore
```

## Architecture

### Data Flow

1. User uploads shapefiles on Upload screen → sent to
   `POST /api/import` as multipart/form-data
2. Backend reads with GeoPandas, detects CRS, reprojects,
   runs import-time cleanup, returns session with file
   list, detection results, and cleanup summary
3. User walks through wizard — each step saves config via
   PATCH endpoints (auto-saved, indicated to the user).
   Address features are created when Project Info and
   Building Assignment are saved.
4. On wizard confirm, frontend sends
   `POST /api/session/{id}/generate` — backend runs
   mapper, generator, assembles all features including
   unlocated Address/Building, display points, LABELS
5. Review screen fetches features via TanStack Query from
   `GET /api/session/{id}/features` — MapLibre renders
   located GeoJSON, TanStack Table displays all features
   including unlocated (Address, Building)
6. User validates → `POST /api/session/{id}/validate` —
   results merge into feature status, table auto-filters
   to errors
7. User exports → `GET /api/session/{id}/export` → export
   confirmation screen → download .imdf ZIP containing
   address.geojson, venue.geojson, building.geojson
   (null geometry), footprint.geojson, level.geojson,
   unit.geojson, and optional opening/fixture/detail

### State Management

**Backend:** In-memory session objects holding imported
GeoDataFrames, wizard configuration, detection results,
mappings, generated features (including Address and
Building unlocated records), and validation state.
Session ID returned on import, passed with all requests.
Sessions expire after configurable TTL (default 24h).
Background task prunes expired sessions hourly. Max
concurrent sessions configurable (default 5).

**Frontend:** Zustand store holds:

- `sessionId` — current backend session
- `currentScreen` — upload / wizard / review
- `wizardStep` — current wizard step index
- `wizardData` — accumulated wizard form data
- `geojsonData` — cached GeoJSON (managed by TanStack
  Query, referenced here for non-query subscribers)
- `selectedFeatureIds` — set of selected UUIDs
- `filters` — type, level, category, status, search
- `layerVisibility` — which types are visible on map
  (located types only)
- `validationResults` — errors, warnings, summary
- `editHistory` — stack of recent property edits for
  Ctrl+Z undo

Map and table subscribe to the same store fields. Zustand
subscriptions mean components only re-render when their
fields change.

**TanStack Query** manages all API data fetching:

- Feature GeoJSON is fetched once after generation and
  cached
- Mutations (PATCH feature, bulk edit, delete) invalidate
  the query cache automatically, triggering a refetch
- Loading and error states are handled by query hooks
  rather than manual state management
- Stale-while-revalidate keeps the UI responsive during
  refetches

### Session Lifecycle

```
POST /api/import
    → Session created with unique ID
    → GeoDataFrames stored in memory
    → TTL timer starts

PATCH /api/session/{id}/wizard/project
    → Address feature created for venue
    → Session updated, TTL timer resets

PATCH /api/session/{id}/wizard/buildings
    → Per-building Address features created if needed
    → Session updated, TTL timer resets

PATCH /api/session/{id}/wizard/*
    → Session updated, TTL timer resets

POST /api/session/{id}/generate
    → Mapper + generator run
    → Address, Building (null geom), Footprint, Level,
      Venue, display points all generated
    → Unit/Opening/Fixture/Detail properties assembled
    → All features stored in session
    → TTL timer resets

PATCH /api/session/{id}/features/*
    → Feature properties updated in session
    → TTL timer resets

POST /api/session/{id}/validate
    → Full validation suite runs against session
    → Validation results stored in session
    → TTL timer resets

GET /api/session/{id}/export
    → Converter assembles IMDF from session
    → ZIP returned with address.geojson,
      building.geojson (null geom), etc.
    → Session remains alive (user may re-export)

Session inactive for SESSION_TTL_HOURS
    → Background task prunes session
    → Memory freed

MAX_SESSIONS reached on new import
    → Oldest inactive session evicted
    → New session created
```

### Config Files

Stored in `backend/config/`:

**Standard (not user-editable):**

- `unit_categories.json` — valid IMDF categories + default

**User-uploadable (via wizard):**

- `filename_keywords.json` — keyword → feature type
- `company_mappings.json` — company code → IMDF category

Uploaded configs are stored per-session so different
projects can use different mappings.

### Error Handling

**Backend:**

- All endpoints return appropriate HTTP status codes:
  - 200 for successful GET/PATCH
  - 201 for successful POST that creates a resource
  - 400 for invalid request data (bad JSON, wrong types)
  - 404 for unknown session ID or feature ID
  - 409 for session limit reached
  - 422 for Pydantic validation failure
  - 500 for unexpected server errors
- Error responses use a consistent JSON shape:

```json
{
  "detail": "Session not found",
  "code": "SESSION_NOT_FOUND"
}
```

- All exceptions are caught and logged before returning
  error responses — no stack traces in API responses
- Geometry processing errors (Shapely, GeoPandas) are
  caught per-feature so one bad geometry does not abort
  the entire import or generation

**Frontend:**

- TanStack Query `onError` callbacks show Shadcn Toast
  notifications for failed API calls
- Error boundary component wraps the MapLibre canvas and
  shows a recovery message if WebGL fails
- Network errors (backend unreachable) show a persistent
  banner with retry option
- Session eviction (404 on session endpoints) shows a
  dialog explaining the session expired and offering to
  re-upload files

## Code Style

**Backend:**

- Type hints on all signatures
- Pydantic models in `schemas.py` for all API shapes
- Dataclasses in `models.py` for internal IMDF domain,
  matching Section 2 property structures exactly
- Business logic in `src/`, route handlers in `routers/`
- No logic in routers — they call src and serialize
- Shapely/GeoPandas for all geometry
- Config loaded at startup, replaceable per-session
- Logging module, not print
- Docstrings on all public functions

**Frontend:**

- TypeScript strict mode
- Functional components with hooks
- Zustand for shared state — no prop drilling
- TanStack Query for all API data fetching and caching
- TanStack Table for all tables (headless, full render
  control)
- Shadcn UI primitives in `components/ui/` (auto-generated
  by Shadcn CLI, kept separate from hand-written code)
- Tailwind for styling — no custom CSS files except for
  MapLibre container sizing
- CSS transitions via Tailwind utilities for wizard step
  animations and drawer slides — no Framer Motion
- API calls through typed `api/client.ts`
- Types matching IMDF Section 2 structures in `types/`
- Pages in `pages/`, reusable components split by context
  (`wizard/`, `review/`, `shared/`)

## Dependencies

### Backend (`requirements.txt`)

```
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
pydantic>=2.5.0
geopandas>=0.14.0
shapely>=2.0.0
fiona>=1.9.0
pyproj>=3.6.0
jsonschema>=4.20.0
python-multipart>=0.0.6
```

### Frontend (`package.json` dependencies)

```json
{
  "dependencies": {
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "react-dropzone": "^14.2.0",
    "react-map-gl": "^7.1.0",
    "maplibre-gl": "^4.5.0",
    "@tanstack/react-table": "^8.11.0",
    "@tanstack/react-query": "^5.17.0",
    "zustand": "^4.5.0",
    "tailwindcss": "^3.4.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0",
    "lucide-react": "^0.312.0"
  },
  "devDependencies": {
    "@types/react": "^18.3.0",
    "@types/react-dom": "^18.3.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0",
    "vitest": "^1.2.0",
    "@testing-library/react": "^14.1.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0"
  }
}
```

Note: Shadcn UI is not a package dependency. It is a CLI
tool (`npx shadcn-ui@latest init`) that copies component
source files into `components/ui/`. The components depend
on `class-variance-authority`, `clsx`, `tailwind-merge`,
and `lucide-react` which are listed above.

## Important Notes

- IMDF requires WGS84 (EPSG:4326) — always reproject
- IMDF output is a ZIP of GeoJSON files, always including
  address.geojson
- Building and Address features have null geometry — they
  appear in the table but not on the map
- Detail features are LineStrings with only level_id — no
  name, no category. They render as thin lines on the map,
  visually distinct from Opening LineStrings
- All names use LABELS format (language-tagged objects),
  never plain strings
- Level features reference buildings via building_ids
  (array), not a single building_id
- Footprint features reference buildings via building_ids
  (array)
- Venue display_point is required by IMDF; building
  display_point must be within a referencing footprint
- Footprint has no display_point property
- Opening has access_control and door properties beyond
  just category
- All geometry validated with `.make_valid()` on import
- Unrecognized category codes default to "unspecified"
- Backend works offline — no external API calls
- Original attributes preserved in metadata field
- MapLibre GL JS v4+ handles WebGL rendering client-side —
  no server rasterization needed
- Map pan/zoom is React state — persists across interactions
- Wizard steps for feature types with no detected files
  show as skippable but remain accessible
- Validation results merge into the feature table as status
  badges — users filter by status to find and fix issues,
  not a separate panel or drawer
- After validation, the table auto-filters to errors so the
  user immediately sees what needs fixing
- Properties panel shows a prominent issue banner when the
  selected feature has a validation error, with guidance on
  how to fix it
- Export requires a confirmation screen summarizing feature
  counts and any remaining warnings before download
- Ctrl+Z undoes the last property edit in the review screen
  via an edit history stack in the Zustand store
- In production, FastAPI serves the built frontend as
  static files — single process, single port
- For dev, Vite proxies /api to backend for hot-reload
- Filters (type, level, status, search) are client-side
  on cached GeoJSON — no API round-trip for filtering
- Sessions expire after configurable TTL and are capped at
  a configurable max count to prevent memory exhaustion
- The Windows PC may need a firewall rule to allow incoming
  connections on port 8000 from the local network
